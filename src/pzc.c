/*
 * pzc.c
 *
 * We save file in format 13 = 1.00
 * DIFFs:
 * format 14 - got one more INT in units
 * format 15
 * Format 14 and 15 introduced by path 1.01 ( changelog of 1.02 does not state about changes in editor)
 * Only few maps in path 1.02 got format 14 or 15
 *
 *  Created on: 2011-08-24
 *      Author: wino
 */
#include <stddef.h>

#include "allegro.h"
#include "loadpng.h"

#include "fpge.h"
#include "pgf.h"
#include "load.h"
#include "pzc.h"
#include "filename.h"
#include "tables.h"
#include "maingui.h"
#include "fpge_colors.h"

/* Generated by HexEdit */
/* C:\Users\wino\Documents\PzC\11.pzscn */

#define HEADERSIZE 0x332-16-16-16-16-12-12-10-5-8-4*9-14*4-1-18-4
#define STDNAMESSIZE (0x162-8 + 20*10)
#define HEXSIZE 0x44
#define VICCONDSIZE 0x1a4

#define MAX_NAMES_PZC 1000
#define STD_NAMES_PZC (16+10)

#define PZC_LOAD_UNITSID 0
#define PZC_LOAD_COUNTRIESID 1
#define PZC_LOAD_TTID 2

int initialization_done=0;
int zoom=1; //zoom=0 std PzC size, zoom=1 PG/PGF sizes

//Not used but left as form of unfinished doc
BYTE hexDataHeader[HEADERSIZE] =
{

  //0x05, 0x00, 0x00, 0x00, 0x31, 0x00, 0x2E, 0x00, 0x70, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x00, 0x00,
  //0x01, 0x00, 0x00, 0x00, 0x92, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  //0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

//  0x04, 0x00, 0x00, 0x00,
//  0x41, 0x00, 0x78, 0x00, 0x69, 0x00, 0x73, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00,
//	0x00, 0x00, 0x00, 0x00,

//  0x01, 0x00, 0x00, 0x00, //right
//  0x00,

  //0x00, 0x00, 0x00, 0x00, //??
  //0x00, 0x00, 0x00, 0x00, //??
  /*
  0x00, 0x00, 0x00, 0x00, //new unit exp

  0x57, 0x02, 0x00, 0x00, //max exp
  0x05, 0x00, 0x00, 0x00, //max over
  0x00, 0x00, 0x00, 0x00, //sea
  0x00, 0x00, 0x00, 0x00, //air
  0x00, 0x00, 0x00, 0x00, //rail
*/
		/*
  0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF,
*/
//ALLIED
		/*
  0x06, 0x00, 0x00, 0x00, 0x41, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x65, 0x00, 0x64, 0x00, 0x00, 0x00, //allied string

  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00,
  0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, //new unit exp
  0x57, 0x02, 0x00, 0x00, //max exp
  0x05, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF,
  */
  //sides
 // 0x00, 0x00, 0x00, 0x00,

  //campaign victory conditions
  0x03, 0x00, 0x00, 0x00, //no

  0x10, 0x00, 0x00, 0x00,
  0x44, 0x00, 0x65, 0x00, 0x63, 0x00, 0x69, 0x00, 0x73, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00,
  0x20, 0x00, 0x56, 0x00, 0x69, 0x00, 0x63, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x79, 0x00,
  0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xFC, 0xFF,
  0xFF, 0xFF,

  0x10, 0x00, 0x00, 0x00,
  0x4D, 0x00, 0x61, 0x00, 0x72, 0x00, 0x67, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x61, 0x00,
  0x6C, 0x00, 0x20, 0x00, 0x56, 0x00, 0x69, 0x00, 0x63, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00,
  0x79, 0x00, 0x00, 0x00,

  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF,

  0x04, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x6F, 0x00, 0x73, 0x00,
  0x73, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF,

  //scenario victory conditions
  0x03, 0x00, 0x00, 0x00, //no
  //string
  0x10, 0x00, 0x00, 0x00,
  0x52, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65, 0x00, 0x61, 0x00, 0x6D, 0x00,
  0x20, 0x00, 0x56, 0x00, 0x69, 0x00, 0x63, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x79, 0x00,
  0x00, 0x00,
  //data
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  //string
  0x11, 0x00, 0x00, 0x00,
  0x42, 0x00, 0x6C, 0x00, 0x75, 0x00, 0x65, 0x00, 0x20, 0x00,
  0x54, 0x00, 0x65, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x20, 0x00,
  0x56, 0x00, 0x69, 0x00, 0x63, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x79,
  0x00, 0x00,
  //data
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF,

  //string
  0x11, 0x00, 0x00, 0x00,
  0x42, 0x00, 0x6C, 0x00, 0x75, 0x00, 0x65, 0x00, 0x20, 0x00,
  0x54, 0x00, 0x65, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x20, 0x00,
  0x56, 0x00, 0x69, 0x00, 0x63, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x79, 0x00,
  0x00, 0x00,
  //data
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,

  //actions
  0x00, 0x00, 0x00, 0x00
};

BYTE hexDataVicCond[VICCONDSIZE] =
{
  0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x41, 0x00, 0x78, 0x00, 0x69, 0x00, 0x73, 0x00,
  0x20, 0x00, 0x44, 0x00, 0x65, 0x00, 0x63, 0x00, 0x69, 0x00, 0x73, 0x00, 0x69, 0x00, 0x76, 0x00,
  0x65, 0x00, 0x20, 0x00, 0x56, 0x00, 0x69, 0x00, 0x63, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00,
  0x79, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x78, 0x00, 0x69, 0x00, 0x73, 0x00, 0x20, 0x00, 0x56, 0x00, 0x69, 0x00, 0x63, 0x00,
  0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x79, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x32, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
  0x00, 0x00, 0x41, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00,
  0x44, 0x00, 0x65, 0x00, 0x63, 0x00, 0x69, 0x00, 0x73, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00,
  0x20, 0x00, 0x56, 0x00, 0x69, 0x00, 0x63, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x79, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x41, 0x00,
  0x6C, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x56, 0x00, 0x69, 0x00,
  0x63, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x79, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};

BYTE hexDataStdNames[STDNAMESSIZE] =
{
  0x08, 0x00, 0x00, 0x00, 0x44, 0x00, 0x65, 0x00, 0x65, 0x00, 0x70,
  0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x61, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x53,
  0x00, 0x68, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x6F, 0x00, 0x77, 0x00, 0x20, 0x00, 0x53,
  0x00, 0x65, 0x00, 0x61, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x61, 0x00, 0x6B,
  0x00, 0x65, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x53, 0x00, 0x77, 0x00, 0x61, 0x00, 0x6D,
  0x00, 0x70, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x43, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x61,
  0x00, 0x72, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x6E,
  0x00, 0x74, 0x00, 0x72, 0x00, 0x79, 0x00, 0x73, 0x00, 0x69, 0x00, 0x64, 0x00, 0x65, 0x00, 0x00,
  0x00, 0x06, 0x00, 0x00, 0x00, 0x42, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65,
  0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x46, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x65, 0x00, 0x73,
  0x00, 0x74, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x54, 0x00, 0x68, 0x00, 0x69, 0x00, 0x63,
  0x00, 0x6B, 0x00, 0x20, 0x00, 0x46, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x65, 0x00, 0x73, 0x00, 0x74,
  0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x48, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x73,
  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x6E, 0x00, 0x74,
  0x00, 0x61, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x48,
  0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x6E,
  0x00, 0x74, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
  0x00, 0x43, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x41,
  0x00, 0x69, 0x00, 0x72, 0x00, 0x66, 0x00, 0x69, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x64, 0x00, 0x00,
  0x00, 0x04, 0x00, 0x00, 0x00, 0x50, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x74, 0x00, 0x00, 0x00, 0x0D,
  0x00, 0x00, 0x00, 0x46, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x74, 0x00, 0x69, 0x00, 0x66, 0x00, 0x69,
  0x00, 0x63, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00,
//10 fake names to make other the out of stock terrains
  0x07, 0x00, 0x00, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x00, 0x00
};

BYTE hexDataHex[HEXSIZE] =
{
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
};
//--------TERRAIN---------------
int pgnation_to_pzcnation[MAX_COUNTRY]={
-1,-1,7,15,12,
-1,-1,4,0,17,
2,13,-1,5,8,
23,6,-1,14,9,
3,24,-1,1,16};

//PG terrain type to PZC terrain type
int pgtt_to_pzctt[MAX_TERRAIN_TYPE]={
		4,4,4,4,1,
		1,1,0,14,4,
		4,4,10,10,10,
		10,10,10,10,13,
		3,12,9,7,-1,
		15,15,6,6,14,
		4,10,10,15,9,
		11,11,14,4,-1
};

//weather table by rezaf
int weather_table[4][13][3]={
{
{0	,0	,0},
{0	,0	,0},
{0	,0	,0},
{0	,0	,0},
{0	,0	,0},
{0	,0	,0},
{0	,0	,0},
{0	,0	,0},
{0	,0	,0},
{0	,0	,0},
{0	,0	,0},
{0	,0	,0}
}
,
{
{20	,29	,2},
{25	,24	,1},
{20	,5	,9},
{23	,0	,10},
{24	,0	,6},
{20	,0	,5},
{20	,0	,5},
{20	,0	,5},
{24	,0	,6},
{22	,1	,11},
{19	,7	,13},
{20	,23	,8}
}
,
{
{40	,6	,4},
{35	,9	,6},
{25	,4	,21},
{20	,2	,29},
{17	,0	,17},
{16	,0	,4},
{16	,0	,4},
{16	,0	,4},
{27	,0	,7},
{40	,1	,9},
{40	,3	,8},
{18	,55	,0}
}
,
{
{20	,30	,0},
{27	,40	,0},
{25	,20	,5},
{30	,12	,8},
{27	,0	,7},
{20	,0	,5},
{20	,0	,5},
{20	,0	,5},
{27	,0	,7},
{30	,16	,4},
{25	,24	,1},
{20	,30	,0}
}
};

//--------RIVERS-----------------
struct river_pzc {
 int tile;
 char pattern[7];
 int corners[6];
 int bits;
};

#define MAX_RIVER_CONVERSIONS_PATTERNS 30

struct river_pzc river_conversion_patterns[MAX_RIVER_CONVERSIONS_PATTERNS] = {
{30 ,"001001"},{32 ,"100010"},{40 ,"100100"},{41 ,"010100"},
{60 ,"001010"},{70 ,"010001"},{223,"001001"},{224,"100100"},
{225,"100010"},{226,"010010"},{54 ,"100010"},{55 ,"000110"},
{61 ,"011000"},{62 ,"000101"},{63 ,"101000"},{64 ,"010010"},
{65 ,"010001"},{71 ,"100100"},{72 ,"001001"},{227,"010100"},
{162,"001001"},{165,"001001"},{229,"000010"},{228,"010000"},
{52 ,"000001"},{53 ,"001000"},{50 ,"001000"},{42 ,"100000"},
{51 ,"000001"},{31 ,"000100"} };

int pat_bits[6] = { 1+2, 2+8, 8+16, 16+32, 32+128, 128+1 };

unsigned char rrc[MAX_MAP_X][MAX_MAP_Y];

//--------NAMES-----------------
int gln_to_pzcn[MAX_NAMES];
int pzcn_to_gln[MAX_NAMES_PZC];
int pzcn_to_gln_no=0;

//--------UNITS-----------------
//PG class to PZC class
int pgclass_to_pzcclass[]=
{0,1,2,3,4,
5,5,6,7,8,
9,10,11,12,13,
14,15,16};

int pgmovtype_to_pzcmovtype[MAX_MOV_TYPE]={
0,1,2,3,4,
5,6,7,0,7,
8
};

int pgunit_to_pzcunit[MAX_UNITS];

struct pzc_unit pzc_unit_conversion[MAX_UNITS];

//------UI
#define PZC_FG_COLOR GUI_FG_COLOR
#define PZC_BG_COLOR GUI_BG_COLOR
#define PZC_EDIT_COLOR GUI_EDIT_COLOR

#define PZC_COL1 198+16
#define PZC_COL2 198+16+96+16

#define PZC_LINES_IN_LISTBOX 27

char new_id[256];
char old_id[256];

DIALOG findpzcid_dlg[PZC_DLG_SIZE]= {
        { d_textbox_proc,0,0,198+96+16+96+16+16,222+16,PZC_FG_COLOR,	PZC_BG_COLOR,	0 ,	0 ,	0 ,	0 ,0},
/* 1 */	{ d_pzc_list_proc   ,	6   ,	6  ,	/*174+16*/ 7*PZC_LINES_IN_LISTBOX ,	222 ,	PZC_FG_COLOR,	PZC_BG_COLOR,	0 , 	0 ,	0 ,	0 ,	(void *)pzc_list},
/* 2 */	{ d_button_proc ,	PZC_COL1 ,	204 ,	96 ,	15 ,	PZC_FG_COLOR,	PZC_BG_COLOR,	'c' ,	D_EXIT ,0 ,	0 ,	 (void *)"&Cancel" },
/* 3 */	{ d_button_proc   ,	PZC_COL2 ,	204 ,	96 ,	15 ,	PZC_FG_COLOR,	PZC_BG_COLOR,	'd' ,	D_EXIT ,0 ,	0 ,	 (void *)"&Done" },
/* 4 */	{ d_edit_proc , 	PZC_COL1 ,	102-80+8+32+16 ,	8*21 ,	15 ,	PZC_FG_COLOR,	PZC_EDIT_COLOR,	0 ,	    0 ,	20 ,1 ,	(void *)new_id},
/* 5 */	{ d_text_proc ,	    PZC_COL1 ,	84-80+8+32+16 ,	96 ,	15 ,	PZC_FG_COLOR,	PZC_BG_COLOR,	0 ,	    0 ,	0 ,	0 ,	 (void *)"PZC ID:" },
/* 6 */	{ d_text_proc ,	    PZC_COL1 ,	84-80+8 ,	96 ,	15 ,	PZC_FG_COLOR,	PZC_BG_COLOR,	0 ,	    0 ,	0 ,	0 ,	 (void *)"FPGE eqp name:" },
/* 7 */	{ d_text_proc ,	    PZC_COL1 ,	84-80+8+16 ,	96 ,	15 ,	PZC_FG_COLOR,	PZC_BG_COLOR,	0 ,	    0 ,	0 ,	0 ,	 (void *)old_id },
		{ d_yield_proc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL },
		{ NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL }
 };

int pzcid_to_display_filter[MAX_UNITS];
int pzcid_to_display[MAX_UNITS];
int pzcid_to_display_number;

char *pzc_list(int index, int *list_size){
     if (index<0){
    	*list_size=pzcid_to_display_number;
        return 0;
     }
     return pzc_unit_conversion[pzcid_to_display[index]].name;
}
int d_pzc_list_proc(int msg, DIALOG *d, int c){
	int d1;

	if (msg==MSG_START){
		if (d->d1 > pzcid_to_display_number) d->d1=-1;

		if (d->d1 > -1){
			sprintf(new_id,"%d",pzcid_to_display[findpzcid_dlg[1].d1]);
		}else{
			strncpy(new_id,"",256);
		}
		findpzcid_dlg[4].flags |= D_DIRTY;
	}

	if (msg==MSG_CLICK || msg == MSG_CHAR){
		d1 = d->d1;
		d_list_proc(msg,d,c);

		if (d1 > -1 || msg == MSG_CLICK)
		{
			sprintf(new_id,"%d",pzcid_to_display[findpzcid_dlg[1].d1]);
			findpzcid_dlg[4].flags |= D_DIRTY;

			if (msg == MSG_CLICK)
				return D_O_K;
			if (msg == MSG_CHAR) {
				if (d1 != d->d1)
					return D_USED_CHAR;
				else
					return D_O_K;
			}
		}
		return D_O_K;
	}

	return d_list_proc(msg,d,c);
}

int get_new_id_gui(int unum, int country, int pzc_country, int pzc_class) {
//	char line[1024];
	int need_to_save = 0;
	int i;
	//int pzc_country = pgnation_to_pzcnation[country>-1?country:0];
	if (country==-1) pzc_country=-1;
	//int pzc_class = pgclass_to_pzcclass[equip[unum][CLASS]];
	int pzc_type = equip[unum][TARGET_TYPE]; // ?? is this true

	printf("Not found : %d %d %d %d ---> %s\n", unum, pzc_country, pzc_class, pzc_type, equip[unum]);

	strncpy(old_id,equip_name_utf8[unum],256);

	for (i = 0; i < MAX_UNITS; i++){
		pzcid_to_display_filter[i]=-1;
		pzcid_to_display[i]=0;
	}
	pzcid_to_display_number=0;

	for (i = 0; i < MAX_UNITS; i++)
		if (pzc_unit_conversion[i].id != -1 && (pzc_country == pzc_unit_conversion[i].flag || pzc_country==-1)
				&& pzc_class == pzc_unit_conversion[i].class
				&& pzc_type == pzc_unit_conversion[i].target_type)
					pzcid_to_display_filter[i]=i;

	for (i = 0; i < MAX_UNITS; i++)
		if (pzcid_to_display_filter[i] !=-1){
			pzcid_to_display[pzcid_to_display_number]=pzcid_to_display_filter[i];
			pzcid_to_display_number++;
		}

	centre_dialog(findpzcid_dlg);
	if (do_dialog(findpzcid_dlg,-1)==3){
		//gets(line);
		if (strlen(new_id) > 0) {
			pgunit_to_pzcunit[unum] = atoi(new_id);
			need_to_save = 1;
		}
	}

	broadcast_dialog_message(MSG_DRAW,0);
	return need_to_save;
}

void init_pzc_conversion_names(){
	int i;

	//names
	for (i=0;i<MAX_NAMES;i++)
		gln_to_pzcn[i]=-1;

	for (i=0;i<STD_NAMES_PZC;i++)
		pzcn_to_gln[i]=i;

	for (i=STD_NAMES_PZC;i<MAX_NAMES_PZC;i++)
		pzcn_to_gln[i]=-1;

	pzcn_to_gln_no=STD_NAMES_PZC; //first 16 names are defaults
}

void init_tables(){
	int x,y;

	if (initialization_done) return;

	initialization_done=1;

	int i,j;
	for (i=0;i<MAX_RIVER_CONVERSIONS_PATTERNS;i++){
		int bits=0;
		for (j=0;j<6;j++){
			if (river_conversion_patterns[i].pattern[j]=='1') {
				river_conversion_patterns[i].corners[j]=1;
				bits|=pat_bits[j];
			}
			else river_conversion_patterns[i].corners[j]=0;
		}
		river_conversion_patterns[i].bits=bits;
	}

	for (y = 1; y < mapy - 1; ++y)
		for (x = 1; x < mapx - 1; ++x)
			rrc[x][y]=0;



	//units
	for (i=0;i<MAX_UNITS;i++){
		pzc_unit_conversion[i].id=-1;
		pgunit_to_pzcunit[i]=-1;
	}
	for (i=12;i<MAX_MOV_TYPE;i++)
		pgmovtype_to_pzcmovtype[i]=-1;

	//countries, first 25 are set
	for (i=25;i<MAX_COUNTRY;i++)
		pgnation_to_pzcnation[i]=-1;

}

void rivers_connections(){
int x,y,i;

//first step, set all possible bits, clear if empty
for (y = 1; y < mapy - 1; ++y)
	for (x = 1; x < mapx - 1; ++x) {
		rrc[x][y]=0;
		for (i = 0; i < MAX_RIVER_CONVERSIONS_PATTERNS; ++i)
			if (map[x][y].tile == river_conversion_patterns[i].tile) {
				rrc[x][y]=river_conversion_patterns[i].bits;
				break;
			}
	}
//one way
for (y = 1; y < mapy - 1; ++y)
	for (x = 1; x < mapx - 1; ++x) {
	int rc=rrc[x][y];

	if (rrc[x][y] > 0) {

		if ((rrc[x][y] & 0x80) && !(rrc[x - 1][y - 1 + x % 2] & 0x08))
			rc &= ~0x80;
		if ((rrc[x][y] & 0x01) && !(rrc[x][y - 1] & 0x10))
			rc &= ~0x01;
		if ((rrc[x][y] & 0x02) && !(rrc[x + 1][y - 1 + x % 2] & 0x20))
			rc &= ~0x02;
		if ((rrc[x][y] & 0x08) && !(rrc[x + 1][y + x % 2] & 0x80))
			rc &= ~0x08;
		if ((rrc[x][y] & 0x10) && !(rrc[x][y + 1] & 0x01))
			rc &= ~0x10;
		if ((rrc[x][y] & 0x20) && !(rrc[x - 1][y + x % 2] & 0x02))
			rc &= ~0x20;
		//printf("rrc[][]=%d rc=%d\n",rrc[x][y],rc);
	}
	tempmap[x][y]=rc;
	}
//
for (y = 1; y < mapy - 1; ++y)
	for (x = 1; x < mapx - 1; ++x){
		rrc[x][y]=tempmap[x][y];
	}
}

int get_new_id_txt(int unum, int country) {
	char line[1024];
	int need_to_save = 0;
	int i;
	int pzc_country = pgnation_to_pzcnation[country>-1?country:0];
	if (country==-1) pzc_country=-1;
	int pzc_class = pgclass_to_pzcclass[equip[unum][CLASS]];
	int pzc_type = equip[unum][TARGET_TYPE]; // ?? is this true

	//printf("Not found : %d %d %d %d --->%s\n", unum, pzc_country, pzc_class, pzc_type, equip[unum]);

	for (i = 0; i < MAX_UNITS; i++)
		if (pzc_unit_conversion[i].id != -1 && (pzc_country == pzc_unit_conversion[i].flag || pzc_country==-1)
				&& pzc_class == pzc_unit_conversion[i].class
				&& pzc_type == pzc_unit_conversion[i].target_type)
			printf("%d--->[%d] %s\n",pzc_unit_conversion[i].id, pzc_unit_conversion[i].flag , pzc_unit_conversion[i].name);

	printf("Enter PzC ID:\n");

	//gets(line);
	fgets(line,1024,stdin);
	if (strlen(line) > 0) {
		pgunit_to_pzcunit[unum] = atoi(line);
		need_to_save = 1;
	}
	return need_to_save;
}

int get_new_id(int unum, int country) {
	return get_new_id_gui(unum,country,pgnation_to_pzcnation[country>-1?country:0], pgclass_to_pzcclass[equip[unum][CLASS]]);
}

void save_pzc_string(FILE *outf, unsigned char *string_to_save){
	int j;
	short c,idx;

	int len=strlen(string_to_save);
	fwrite(&len,4,1,outf);
	//if (len==0)
	//	return;

	for(j=0;j<=len;j++){
		idx=string_to_save[j];
		c= cp1250_to_utf[idx];
		fwrite(&c,2,1,outf);
	}
}

void load_conversion_tables(){

	int result;

    printf("Trying to load '%s' file.\n",pgu2pzcu_file);
    result= load_pg_to_pzc_conversion_file(LOAD_FILE, pgu2pzcu_file, PZC_LOAD_UNITSID);
    if (!result){
   	 printf("'%s' file loaded.\n",pgu2pzcu_file);
    }

    printf("Trying to load '%s' file.\n",pgc2pzcc_file);
    result= load_pg_to_pzc_conversion_file(LOAD_FILE, pgc2pzcc_file, PZC_LOAD_COUNTRIESID);
    if (!result){
   	 printf("'%s' file loaded.\n",pgc2pzcc_file);
    }

    printf("Trying to load '%s' file.\n",pgtt2pzctt_file);
    result= load_pg_to_pzc_conversion_file(LOAD_FILE, pgtt2pzctt_file, PZC_LOAD_TTID);
    if (!result){
   	 printf("'%s' file loaded.\n",pgtt2pzctt_file);
    }
}

int save_pzscn(){
	 char path[MAX_PATH];
	 char line[1024];
	 char scenario_name[1024];
	 char tmp_line[1024];
	 int i,j,tmp,x,y;
	 int need_to_save=0;
	 int pclouds,prain,psnow;
     FILE *outf;

     init_tables();
     init_pzc_conversion_names(); //always init names

     int result= load_pzc_equipment(LOAD_FILE, pzc_equip_file);
     if (result){
 		alert("ERROR: Cannot load 'equipment.pzeqp' equipment file.", NULL, NULL, "&Continue", NULL, 'c', 0);
 		return D_O_K;
     }
     sprintf(MapStatusTxt,"Exporting to PzC");
     d_mapstatus_proc(MSG_DRAW,&(main_dlg[dmMapStatusIdx]),0);

     load_conversion_tables();

     //first check if all units can be converted
     for (j = 0; j < total_units; j++) {
		if (pgunit_to_pzcunit[all_units[j].unum] == -1) {
			//print_dec(all_units[j].unum);
			//print_dec(all_units[j].x);
			//print_dec(all_units[j].y);
			if (get_new_id(all_units[j].unum,all_units[j].country))
				need_to_save=1;
		}

		if (all_units[j].orgtnum>0 && pgunit_to_pzcunit[all_units[j].orgtnum]== -1) {
			//print_dec(all_units[j].orgtnum);
			if (get_new_id(all_units[j].orgtnum,all_units[j].country))
				need_to_save=1;
		}

		if (all_units[j].auxtnum>0 && pgunit_to_pzcunit[all_units[j].auxtnum]== -1) {
			//print_dec(all_units[j].auxtnum);
			if (get_new_id(all_units[j].auxtnum,all_units[j].country))
				need_to_save=1;
		}
     }
     //check transports
     tmp=s4_buffer[AXIS_SEA_TYPE]+s4_buffer[AXIS_SEA_TYPE+1]*256;
	 if (tmp>0 && pgunit_to_pzcunit[tmp] == -1) {
		if (get_new_id(tmp,-1)) need_to_save=1;
	 }
     tmp=s4_buffer[AXIS_AIR_TYPE]+s4_buffer[AXIS_AIR_TYPE+1]*256;
	 if (tmp>0 && pgunit_to_pzcunit[tmp] == -1) {
		if (get_new_id(tmp,-1)) need_to_save=1;
	 }
     tmp=s4_buffer[ALLIED_SEA_TYPE]+s4_buffer[ALLIED_SEA_TYPE+1]*256;
	 if (tmp>0 && pgunit_to_pzcunit[tmp] == -1) {
		if (get_new_id(tmp,-1)) need_to_save=1;
	 }
     tmp=s4_buffer[ALLIED_AIR_TYPE]+s4_buffer[ALLIED_AIR_TYPE+1]*256;
	 if (tmp>0 && pgunit_to_pzcunit[tmp] == -1) {
		if (get_new_id(tmp,-1)) need_to_save=1;
	 }
	  //Name
	  if (pgf_mode)
		  sprintf(scenario_name,"%s",block1_Name);
	  else{
		  convert_from_cp1250_to_utf8(tmp_line,scn_short_description[getScenarioNumber()-1],SHORT_SCN_SIZE);
		  sprintf(scenario_name,"%s",tmp_line);
	  }

    sprintf(path,".\\%s.pzscn",scenario_name);
    canonicalize_filename(path,path,MAX_PATH);
	if (file_select_ex("Save PZSCN scenario file",path,"pzscn", MAX_PATH, OLD_FILESEL_WIDTH, OLD_FILESEL_HEIGHT)){

	canonicalize_filename(path,path,MAX_PATH);
	outf=fopen(path,"wb");
	if (!outf){
		alert("ERROR: Cannot save PZSCN scenario file.", "Access to file denied", NULL, "&Continue", NULL, 'c', 0);
		return D_O_K;
	}
	tmp=15; //file format version. Patch 1.01/1.02
	fwrite(&tmp,4,1,outf);

	  if (pgf_mode){
		  //scenario name
		  strncpy(line,block1_Name,1024);
		  save_pzc_string(outf,line);
		  //scenario description
		  strncpy(line,block1_Description,1024);
		  save_pzc_string(outf,line);
	  }else{
		  //scenario name
		  convert_from_cp1250_to_utf8(line,scn_short_description[getScenarioNumber()-1],SHORT_SCN_SIZE);
		  save_pzc_string(outf,line);
		  //scenario description
		  convert_from_cp1250_to_utf8(line,scn_long_description[getScenarioNumber()-1],LONG_SCN_SIZE);
		  save_pzc_string(outf,line);
	  }
	  save_pzc_string(outf,"default.png");
   //turns
	tmp=scn_buffer[TURNS];
	fwrite(&tmp,4,1,outf);
	tmp=1900+scn_buffer[YEAR];
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[MONTH];
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[DAY];
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[DAYS_PER_TURN];
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[TURNS_PER_DAY];
	fwrite(&tmp,4,1,outf);
	//clouds, rain, snow - using rezaf weather table
	if (scn_buffer[STORM_FRONT]<=3){
		pclouds=weather_table[scn_buffer[STORM_FRONT]][scn_buffer[MONTH]][0];
		prain=weather_table[scn_buffer[STORM_FRONT]][scn_buffer[MONTH]][1];
		psnow=weather_table[scn_buffer[STORM_FRONT]][scn_buffer[MONTH]][2];

	}else{
		pclouds=0;
		prain=0;
		psnow=0;
	}
	//printf("%d %d %d\n",pclouds,prain,psnow);
	fwrite(&pclouds,4,1,outf);
	fwrite(&prain,4,1,outf);
	fwrite(&psnow,4,1,outf);
	//ground state, moisture
	tmp=0;
	fwrite(&tmp,4,1,outf);
	fwrite(&tmp,4,1,outf);
	//sides
	// AXIS
	save_pzc_string(outf,"Axis");
	tmp= s4_buffer[AXIS_PRESTIGE]+256*s4_buffer[AXIS_PRESTIGE+1];
	fwrite(&tmp,4,1,outf);
	tmp=0; //prestige per turn
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[CORE_UNITS_LIMIT];
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[AUX_UNITS_LIMIT];
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[ORIENTATION]==0xff?1:0;
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[AXIS_STANCE]; //??
	fwrite(&tmp,1,1,outf); //one byte

	tmp=axis_experience;
	fwrite(&tmp,4,1,outf);
	tmp=atoi(block1_Max_Unit_Experience);
	fwrite(&tmp,4,1,outf);
	tmp=atoi(block1_Max_Unit_Strength)-10;
	fwrite(&tmp,4,1,outf);

	tmp=s4_buffer[AXIS_SEA_NUMBER];
	fwrite(&tmp,4,1,outf);
	tmp=s4_buffer[AXIS_AIR_NUMBER];
	fwrite(&tmp,4,1,outf);
	tmp=0; //rail==0
	fwrite(&tmp,4,1,outf);

    tmp=pgunit_to_pzcunit[s4_buffer[AXIS_SEA_TYPE]+s4_buffer[AXIS_SEA_TYPE+1]*256];
    fwrite(&tmp,4,1,outf);
    tmp=pgunit_to_pzcunit[s4_buffer[AXIS_AIR_TYPE]+s4_buffer[AXIS_AIR_TYPE+1]*256];
    fwrite(&tmp,4,1,outf);
    tmp=-1; //rail==-1
    fwrite(&tmp,4,1,outf);

    //Now ALLIED
	save_pzc_string(outf,"Allied");
	tmp= s4_buffer[ALLIED_PRESTIGE]+256*s4_buffer[ALLIED_PRESTIGE+1];
	fwrite(&tmp,4,1,outf);
	tmp=0; //prestige per turn
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[ALLIED_UNITS_LIMIT];
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[ALLIED_AUX_UNITS_LIMIT];
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[ORIENTATION]==0xff?0:1; //negative to axis
	fwrite(&tmp,4,1,outf);
	tmp=scn_buffer[ALLIED_STANCE]; //??
	fwrite(&tmp,1,1,outf); //one byte

	tmp=allied_experience;
	fwrite(&tmp,4,1,outf);
	tmp=atoi(block1_Max_Unit_Experience);
	fwrite(&tmp,4,1,outf);
	tmp=atoi(block1_Max_Unit_Strength)-10;
	fwrite(&tmp,4,1,outf);

	tmp=s4_buffer[ALLIED_SEA_NUMBER];
	fwrite(&tmp,4,1,outf);
	tmp=s4_buffer[ALLIED_AIR_NUMBER];
	fwrite(&tmp,4,1,outf);
	tmp=0; //rail==0
	fwrite(&tmp,4,1,outf);

    tmp=pgunit_to_pzcunit[s4_buffer[ALLIED_SEA_TYPE]+s4_buffer[ALLIED_SEA_TYPE+1]*256];
    fwrite(&tmp,4,1,outf);
    tmp=pgunit_to_pzcunit[s4_buffer[ALLIED_AIR_TYPE]+s4_buffer[ALLIED_AIR_TYPE+1]*256];
    fwrite(&tmp,4,1,outf);
    tmp=-1; //rail==-1
    fwrite(&tmp,4,1,outf);

    //sides nations
    //number of nations, only nations that can be converted
    tmp=0;
    for(j=0;j<12;j++)
    	if (pgnation_to_pzcnation[scn_buffer[j]]!=-1) tmp++;
    fwrite(&tmp,4,1,outf);
    //
    for(j=0;j<12;j++)
    	if (pgnation_to_pzcnation[scn_buffer[j]]!=-1) {
    		//flag
    		tmp=pgnation_to_pzcnation[scn_buffer[j]];
    		fwrite(&tmp,4,1,outf);
    		//side
    		tmp=j%2;
    		fwrite(&tmp,4,1,outf);
    	}

	// the rest of scenario header - unknow format
	//fwrite(&hexDataHeader,HEADERSIZE,1,outf);

    //number of campaign victory conditions
    tmp=0;
	fwrite(&tmp,4,1,outf);

	//predefined victory conditions
    fwrite(&hexDataVicCond,VICCONDSIZE,1,outf);

	//map x,y
	fwrite(&mapx,4,1,outf);
	fwrite(&mapy,4,1,outf);
    //two magic numbers
	tmp=8;
	fwrite(&tmp,4,1,outf);
	tmp=4;
	fwrite(&tmp,4,1,outf);

	rivers_connections();

	for(y=0;y<mapy;y++)
		for(x=0;x<mapx;x++)
		{
			//background tile - experiment
			//for(i=0;i<4;i++)
			//	hexDataHex[i]=0;
			//hexDataHex[0]=map[x][y].tile;

			//terrain type
			hexDataHex[16*3]=pgtt_to_pzctt[map[x][y].utr];
			//name
			hexDataHex[16*3+4]=pgtt_to_pzctt[map[x][y].utr];
			hexDataHex[16*3+4+1]=0;
			int ggln = map[x][y].gln;
			if (!is_tile_name_standard(ggln) && ggln<total_names){
				//check if already assigned
				if (gln_to_pzcn[ggln]==-1){ //no assigned
					gln_to_pzcn[ggln]=pzcn_to_gln_no;
					pzcn_to_gln[pzcn_to_gln_no]=ggln;
					pzcn_to_gln_no++;
				}
				hexDataHex[16*3+4]=gln_to_pzcn[ggln]%256;
				hexDataHex[16*3+4+1]=gln_to_pzcn[ggln]>>8;
			}

			hexDataHex[16*3-4]=map[x][y].rc;
			hexDataHex[16*3-4*3]=rrc[x][y];
			if (pgnation_to_pzcnation[map[x][y].own] != -1){
				hexDataHex[16*3+8]=pgnation_to_pzcnation[map[x][y].own];
				for(i=0;i<3;i++) hexDataHex[16*3+8+1+i]=0;
			}
			else {
				//put -1
				hexDataHex[16*3+8]=0xfe;
				for(i=0;i<3;i++)
					hexDataHex[16*3+8+1+i]=0xff;
			}
			hexDataHex[16*3+4+8]=0 + map[x][y].vic?2:0 + map[x][y].side==3?1:0 + map[x][y].deploy?4:0;

			fwrite(&hexDataHex,HEXSIZE,1,outf);
		}

	//names block
	fwrite(&pzcn_to_gln_no,4,1,outf);
	fwrite(&hexDataStdNames,STDNAMESSIZE,1,outf); //standard names
	for(i=STD_NAMES_PZC;i<pzcn_to_gln_no;i++){
		save_pzc_string(outf,gln[pzcn_to_gln[i]]);
		//printf("%d %s\n",i,gln[pzcn_to_gln[i]]);
//		int len=strlen(gln[pzcn_to_gln[i]]);
//		fwrite(&len,4,1,outf);
//		short c;
//		for(j=0;j<=len;j++){
//			c= gln[pzcn_to_gln[i]][j];
//			fwrite(&c,2,1,outf);
//		}
	}

	// now units
	fwrite(&total_units,4,1,outf);

	for (j = 0; j < total_units; j++){
		//all_units[j].unum
		tmp = all_units[j].x + all_units[j].y * mapx ; //x,y
		fwrite(&tmp,4,1,outf);
		tmp = equip[all_units[j].unum][GAF];
		fwrite(&tmp,4,1,outf); //ground=0 air=1
		tmp=0;
		fwrite(&tmp,4,1,outf); //units name with mandatory 2-bytes 0
		fwrite(&tmp,2,1,outf);
		//new ID
		tmp=pgunit_to_pzcunit[all_units[j].unum];
		fwrite(&tmp,4,1,outf);
		//org tra
		tmp=-1;
		if (all_units[j].orgtnum>0) tmp=pgunit_to_pzcunit[all_units[j].orgtnum];
		fwrite(&tmp,4,1,outf);
		//transport
		tmp=-1;
		if (all_units[j].auxtnum>0) tmp=pgunit_to_pzcunit[all_units[j].auxtnum];
		fwrite(&tmp,4,1,outf);

		//side
		tmp=0;
		if (all_units[j].uflag == allied_core || all_units[j].uflag == allied_aux ) tmp=1;
		fwrite(&tmp,4,1,outf);

		//flag
		tmp=pgnation_to_pzcnation[all_units[j].country];
		fwrite(&tmp,4,1,outf);

		//aux?
		tmp=0;
		if (all_units[j].uflag == allied_aux || all_units[j].uflag == axis_aux) tmp=1;
		fwrite(&tmp,1,1,outf); //one byte

		//str
		tmp=all_units[j].str;
		fwrite(&tmp,4,1,outf);
		//sup
		tmp=0;
		fwrite(&tmp,4,1,outf);
		//exp
		tmp=all_units[j].exp;
		fwrite(&tmp,4,1,outf);
		//ent
		tmp=all_units[j].entrench;
		fwrite(&tmp,4,1,outf);
		//fuel, amo
		tmp=-1;
		fwrite(&tmp,4,1,outf);
		fwrite(&tmp,4,1,outf);
		//AI type
		tmp=0;
		fwrite(&tmp,4,1,outf);
		//null triger - file format >= 14
		tmp=0;
		fwrite(&tmp,4,1,outf);
	}

	fclose(outf);
	printf("'%s.pzscn' PzC scenario file saved.\n",scenario_name);
	//save conversion table
	if (need_to_save) {
			result = save_pgunit_to_pzcunit();
			if (!result) {
				printf("'%s' file saved.\n", pgu2pzcu_file);
			}
		}
	sprintf(MapStatusTxt,"PzC file saved.\nPick an Operation.");
	main_dlg[dmMapStatusIdx].flags |= D_DIRTY;
	}
	return D_O_K;
}

//load pzc corps equipment
int load_pzc_equipment(int probe_file_only, char *fname){

	FILE *inf;
	char line[1024],tokens[50][256];
	int i,cursor=0,token=0,lines,loaded=0;
	//int token_len, token_write;
	char path[MAX_PATH];

	strncpy(path,fname,MAX_PATH);
	//printf("%s\n",fname);
	canonicalize_filename(path,path,MAX_PATH);
	//printf("%s\n",path);
	inf = fopen(path, "rb");
	if (!inf) {
		return ERROR_PZC_EQUIP_BASE + ERROR_FPGE_FILE_NOT_FOUND;
	}
	if (probe_file_only == PROBE_FILE) {
		fclose(inf);
		return ERROR_PZC_EQUIP_BASE + ERROR_FPGE_FILE_FOUND;
	}
	lines = 0;

	while (read_utf16_line_convert_to_utf8(inf, line) >= 0) {
		//count lines so error can be displayed with line number
		lines++;

		for (i = 0; i < strlen(line); i++)
			if (line[i] == 0x23) {
				line[i] = 0;
				break;
			}

		token = 0;
		cursor = 0;
		for (i = 0; i < strlen(line); i++)
			if (line[i] == 0x09) {
				tokens[token][cursor] = 0;
				token++;
				cursor = 0;
			} else {
				tokens[token][cursor] = line[i];
				cursor++;
			}
		tokens[token][cursor] = 0;
		token++;
		//if (lines<10) printf("%d %d \n",lines,token);
		if (token > 28 && strlen(tokens[0])>0 && strlen(tokens[1])>0 && strlen(tokens[2])>0 && strlen(tokens[17])>0 && strlen(tokens[18])>0 ) {
			i = atoi(tokens[0]);
			loaded++;
			pzc_unit_conversion[i].id = i;
			strncpy(pzc_unit_conversion[i].name, tokens[1], 256);
			pzc_unit_conversion[i].class = (unsigned char) atoi(tokens[2]);
			pzc_unit_conversion[i].target_type = (unsigned char) atoi(tokens[17]);
			pzc_unit_conversion[i].flag = (unsigned char) atoi(tokens[18]);
		}
	}
	//printf("loaded : %d of %d lines\n",loaded, lines);
	fclose(inf);
	return 0;
}

int load_pg_to_pzc_conversion_file(int probe_file_only, char *fname, int mode){
	FILE *inf;
	char line[1024],tokens[50][256];
	int i,cursor=0,token=0,lines,count=0;
	char path[MAX_PATH];
	int error_base=ERROR_PGUNIT_TO_PZCUNIT_BASE;

	if (mode == PZC_LOAD_COUNTRIESID) error_base=ERROR_PGCOUNTRY_TO_PZCCOUNTRY_BASE;
	if (mode == PZC_LOAD_TTID) error_base=ERROR_PGTT_TO_PZCTT_BASE;

	strncpy(path,fname,MAX_PATH);
	canonicalize_filename(path,path,MAX_PATH);
	inf = fopen(path, "rb");
	if (!inf) {
		return error_base + ERROR_FPGE_FILE_NOT_FOUND;
	}
	if (probe_file_only == PROBE_FILE) {
		fclose(inf);
		return error_base + ERROR_FPGE_FILE_FOUND;
	}
	lines = 0;

	while (read_utf16_line_convert_to_utf8(inf, line) >= 0) {
		//count lines so error can be displayed with line number
		lines++;

		for (i = 0; i < strlen(line); i++)
			if (line[i] == 0x23) {
				line[i] = 0;
				break;
			}

		token = 0;
		cursor = 0;
		for (i = 0; i < strlen(line); i++)
			if (line[i] == 0x09) {
				tokens[token][cursor] = 0;
				token++;
				cursor = 0;
			} else {
				tokens[token][cursor] = line[i];
				cursor++;
			}
		tokens[token][cursor] = 0;
		token++;

		if (token >= 2) {
			int idx= atoi(tokens[0]);
			int value = atoi(tokens[1]);
			if (mode == PZC_LOAD_UNITSID)
				if (idx>-1 &&idx<MAX_UNITS){
					pgunit_to_pzcunit[idx]=value;
					count++;
				}
			if (mode == PZC_LOAD_COUNTRIESID)
				if (idx>-1 &&idx<MAX_COUNTRY){
					pgnation_to_pzcnation[idx]=value;
					count++;
				}
			if (mode == PZC_LOAD_TTID)
				if (idx>-1 &&idx<MAX_TERRAIN_TYPE){
					pgtt_to_pzctt[idx]=value;
					count++;
				}
		}
	}
	fclose(inf);

	printf("Read %d lines, %d values set.\n",lines,count);

	return 0;
}

int save_pgunit_to_pzcunit(){
	int i;
	char line[1024], temp_str[256];
    char path[MAX_PATH];
    FILE *outf;

    strncpy(path,pgu2pzcu_file,MAX_PATH);

    canonicalize_filename(path,path,MAX_PATH);
	outf=fopen(path,"wb");
	if (!outf){
		printf("ERROR: Cannot save '%s' file.\n",pgu2pzcu_file);
		return D_O_K;
	}

	fwrite(&UCS2_header,sizeof(UCS2_header),1,outf);
    fake_UTF_write_string_with_eol(outf,"# FPGE conversion file : PG unit ID to PzC unit ID");
	strncpy(line,"#PG unit ID\tPzC unit ID",1024);
    fake_UTF_write_string_with_eol(outf,line);

	for(i=0;i<MAX_UNITS;i++){
		if (pgunit_to_pzcunit[i]!= -1 ){
			strncpy(line,"",1024);

			sprintf(temp_str,"%d\t",i); //PG ID
			strncat(line,temp_str,256);

			sprintf(temp_str,"%d",pgunit_to_pzcunit[i]); //PGZ ID
			strncat(line,temp_str,256);

			sprintf(temp_str,"\t#%s->%s",equip_name_utf8[i],conversion_equip[pgunit_to_pzcunit[i]].name); //names
			strncat(line,temp_str,256);

			fake_UTF_write_string_with_eol(outf,line);
		}
	}
	fclose(outf);
	return D_O_K;
}


int save_pzeqp(){
	 char path[MAX_PATH];
	 char line[1024];
//	 char scenario_name[1024];
	 char temp_str[1024];
	 int unit_id;

     FILE *outf;

    strncpy(path,pzc_equip_file,MAX_PATH);
    canonicalize_filename(path,path,MAX_PATH);
	if (file_select_ex("Save PZEQP equipment file",path,"pzeqp", MAX_PATH, OLD_FILESEL_WIDTH, OLD_FILESEL_HEIGHT)){

	canonicalize_filename(path,path,MAX_PATH);
	outf=fopen(path,"wb");
	if (!outf){
		alert("ERROR: Cannot save PZEQP equipment file.", "Access to file denied", NULL, "&Continue", NULL, 'c', 0);
		return D_O_K;
	}

	init_tables();
	load_conversion_tables();

    strncpy(line,"# ID	Short Name	Class	Cost	Max Ammo	Max Fuel	"
	"Movement	Spotting	Range	Initiative	Soft Attack	Hard Attack	Air Attack	Naval Attack	"
	"Ground Defense	Air Defense	Close Defense	Target Type	Flag	Icon	"
	"Available From	Available Till	Type of Movement	Rate Of Fire	Max Strength	Full Name	"
	"Add Traits	Remove Traits	Series	Multipurpose",1024);

	fwrite(&UCS2_header,sizeof(UCS2_header),1,outf);
    //fake_UTF_write_string_with_eol(outf,"# PanzerCorps equipment table\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t");
    fake_UTF_write_string_with_eol(outf,"# PanzerCorps equipment table created with FPGE\t");
    //fake_UTF_write_string_with_eol(outf,"# PanzerCorps equipment table\t");

    fake_UTF_write_string_with_eol(outf,line);

    for(unit_id=0;unit_id<total_equip;unit_id++){
		strncpy(line,"",1024);
		sprintf(temp_str,"%d\t",unit_id); //ID
		strncat(line,temp_str,1024);
		//quote(temp_str,equip_name_utf8[unit_id]);//Name
		//sprintf(temp_str,"%s\t",temp_str);
		sprintf(temp_str,"%s\t",equip_name_utf8[unit_id]);
		strncat(line,temp_str,1024);

		sprintf(temp_str,"%d\t",pgclass_to_pzcclass[equip[unit_id][CLASS]]); //class
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][COST]*COST_DIVISOR); //Cost
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][AMMO]); //Max Ammo
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][FUEL]); //Max Fuel
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][MOV]); //Movement
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][SPOTTING]); //Spotting
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][RANGE]); //Range
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][INITIATIVE]); //Initiative
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][SA]); //Soft
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][HA]); //Hard
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][AA]); //Air
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][NA]); //Naval
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][GD]); //Ground defence
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][AD]); //Air Defence
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][CD]); //Close Defence
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",equip[unit_id][TARGET_TYPE]); // Target Type
		strncat(line,temp_str,1024);

		if ( (pg_mode || ag_mode) && nupl_present) {
			int i,j,cursor;
			for (i = 0; i < NUPL_COUNTRY_IDX; i++)
				for (j = 0; j < NUPL_CLASS_IDX; j++) {
					cursor = nupl_cc[i][j];
					while (nupl[cursor] != -1) {
						if (equip_country[nupl[cursor]] == -1) {
							equip_country[nupl[cursor]] = nupl_countries[i];
						}
						cursor++;
					}
				}
		}

		int ctr=equip_country[unit_id]>0?pgnation_to_pzcnation[(unsigned char)equip_country[unit_id]]:-1;
		sprintf(temp_str,"%d\t",ctr); // Flag
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d.png\t",(int)equip[unit_id][BMP]+256*equip[unit_id][BMP+1]); //Icon
		strncat(line,temp_str,1024);
		sprintf(temp_str,"01.%02d.19%02d\t",equip[unit_id][MON],equip[unit_id][YR]); //Month+Year
		strncat(line,temp_str,1024);
		sprintf(temp_str,"31.12.19%02d\t",equip[unit_id][LAST_YEAR]); //Last Year
		strncat(line,temp_str,1024);
		sprintf(temp_str,"%d\t",pgmovtype_to_pzcmovtype[equip[unit_id][MOV_TYPE]]); // Movement type
		strncat(line,temp_str,1024);
		strncpy(temp_str,"\t\t\t",1024); //empty Rate Of Fire, Max Strength and full name
		strncat(line,temp_str,1024);

		strncpy(temp_str,"",1024);
		strncat(line,temp_str,1024);

		if (equip[unit_id][CLASS]==CLASS_INFANTRY) strncat(line,"close ",1024);
		if (equip[unit_id][CLASS]==CLASS_TANK) strncat(line,"rott ",1024);
		if (equip[unit_id][CLASS]==CLASS_ANTI_TANK && equip[unit_id][TARGET_TYPE]==1) strncat(line,"fixedt ",1024);
		strncpy(temp_str,"\t\t",1024); //empty Remove Traits, Series, Multipurpose
		strncat(line,temp_str,1024);

		fake_UTF_write_string_with_eol(outf,line);
    }

	fclose(outf);
	printf("'%s' PzC equipment file saved.\n",get_filename(path));

	sprintf(MapStatusTxt,"PZEQP file saved.\nPick an Operation.");
	main_dlg[dmMapStatusIdx].flags |= D_DIRTY;
	}
	return D_O_K;
}

int save_pzc_units(){
	int i,j,x,y,c,dy,flip=0,air=0;
    char filename[64];
    BITMAP *pic, *pic1, *pic2, *pic3;
    int tdx,tdy;
    int tbdx,tbdy;

    if (zoom == 0) {
		tdx = TILE_FULL_WIDTH * 2;
		tdy = TILE_HEIGHT * 2;
		tbdx = TILE_FULL_WIDTH * 3;
		tbdy = TILE_HEIGHT * 3;
	} else {
		tdx = TILE_FULL_WIDTH;
		tdy = TILE_HEIGHT ;
		tbdx = TILE_FULL_WIDTH *3 ;
		tbdy = TILE_HEIGHT *3 ;
	}

	sprintf(MapStatusTxt,"PzC units PNG saving...\nPlease wait.");
	d_mapstatus_proc(MSG_DRAW, &(main_dlg[dmMapStatusIdx]), 0);

	for(i=0;i<total_uicons;i++){

		//ugly but necessary. We do linear search if unit is AIR
		dy=296;
		air=0;
		for(j=0;j<total_equip;j++)
			if ((int)equip[j][BMP]+(int)equip[j][BMP+1]*256 == i){
				if (equip[j][GAF]){
					dy=444;
					air=1;
				}
				flip=0;
				if (country_side[(int)equip_country[j]]==1) flip=1;
				break;
			}

		pic = create_bitmap_ex(32,296,dy);
		clear_bitmap(pic);
		pic1 = create_bitmap_ex(32,TILE_FULL_WIDTH,TILE_HEIGHT);
		clear_bitmap(pic1);
		pic2 = create_bitmap_ex(32,TILE_FULL_WIDTH,TILE_HEIGHT);
		clear_bitmap(pic2);
		pic3 = create_bitmap_ex(32,256,256);
		clear_bitmap(pic3);

		for (y=0; y<TILE_HEIGHT; ++y)
		  for (x=0; x<TILE_FULL_WIDTH; ++x){
		      c= getpixel(unit_bmp[i],x,y);
		      if ( c!=fpge_mask_color)
		    	  c |= 0xFF000000;
		      else
		    	  c=0;
			  putpixel(pic1,(flip?TILE_FULL_WIDTH-x-1:x),y,c);
		  }

		draw_sprite_h_flip(pic2,pic1,0,0);

		masked_stretch_blit(pic1,pic,
				0,0,TILE_FULL_WIDTH,TILE_HEIGHT,
				74-tdx/2,(air?48:74)-tdy/2,tdx,tdy);
		masked_stretch_blit(pic2,pic,
				0,0,TILE_FULL_WIDTH,TILE_HEIGHT,
				222-tdx/2,(air?48:74)-tdy/2,tdx,tdy);

		masked_blit(pic1,pic,
				0,0,
				74-tdx/4,(air?180:234)-tdy/4,tdx/2,tdy/2);
		masked_blit(pic2,pic,
				0,0,
				222-tdx/4,(air?180:234)-tdy/4,tdx/2,tdy/2);

		if (air){
			masked_stretch_blit(pic1,pic,
					0,0,TILE_FULL_WIDTH,TILE_HEIGHT,
					74-tdx/2,344-tdy/2,tdx,tdy);
			masked_stretch_blit(pic2,pic,
					0,0,TILE_FULL_WIDTH,TILE_HEIGHT,
					222-tdx/2,344-tdy/2,tdx,tdy);

		}

		sprintf(filename,"pzc_ub%d.png",i);

		masked_stretch_blit(pic1,pic3,
				0,0,TILE_FULL_WIDTH,TILE_HEIGHT,
				128-tbdx/2,128-tbdy/2,
				tbdx,tbdy);

		save_png(filename,pic3,NULL);

		sprintf(filename,"%d.png",i);
		save_png(filename,pic,NULL);
		destroy_bitmap(pic);
		destroy_bitmap(pic1);
		destroy_bitmap(pic2);
		destroy_bitmap(pic3);
	}

	sprintf(MapStatusTxt,"PzC units files saved.\nPick an Operation.");
	main_dlg[dmMapStatusIdx].flags |= D_DIRTY;

	return D_O_K;
}

// 136x136 per flag
// 8,4 flags columns x row
// 28, 103 X,Y flag position
// 22,17 flag size

//source flags : X,Y = 20,36 - DX,DY = 20,13
int save_pzc_flags(){
	char filename[64];
	int i,c,x,y,a;
    BITMAP *pic, *pic1, *pic2, *pic3, *pic4;

	sprintf(MapStatusTxt,"PzC flags PNG saving...\nPlease wait.");
	d_mapstatus_proc(MSG_DRAW, &(main_dlg[dmMapStatusIdx]), 0);

	pic = create_bitmap_ex(32,136*8,136*4);
	clear_bitmap(pic);
	pic1 = create_bitmap_ex(32,20,13);
	clear_bitmap(pic1);
	pic2 = create_bitmap_ex(32,22,17);
	clear_bitmap(pic2);
	pic3 = create_bitmap_ex(32,21,21);
	clear_bitmap(pic3);
	pic4 = create_bitmap_ex(32,21,21);
	clear_bitmap(pic4);
	circlefill(pic4, 10	,10, 10, makeacol32(0,0,0,0xff));

	for(i=-1;i<Min(total_countries,8*4-1);i++){

	for (y=0; y<13; ++y)
	  for (x=0; x<20; ++x){
		  if (i!=-1)
			  c= getpixel(flag_bmp[i],x+20,y+36);
		  else
			  c=0xffffff; //very first white flags without black shadow
		  if ( c!=fpge_mask_color)
			  c |= 0xFF000000;
		  else
			  c=0;
		  putpixel(pic1,x,y,c);
		  //putpixel(pic,x+ ( (i+1)%8 )*136 +28 ,y+(i+1)/8*136+103,c);
	  }
	stretch_blit(pic1, pic, 0, 0, 20, 13, ( (i+1)%8 )*136 +28, (i+1)/8*136+103, 22, 17);
	//individal flags
	stretch_blit(pic1, pic2, 0, 0, 20, 13, 0, 0, 22, 17);
	sprintf(filename,"pzc_f%d.png",i+1);
	save_png(filename,pic2,NULL);

	//blend to circle
	stretch_blit(pic1, pic3, 0, 0, 19, 12, 0, 0, 21, 21); //one less pixel from source to skip black shadow
	for (y=0; y<21; ++y)
	  for (x=0; x<21; ++x){
		  c=getpixel(pic3,x,y);
		  a=getpixel(pic4,x,y);
		  putpixel(pic3,x,y,makeacol32(getr(c),getg(c),getb(c),geta(a)));
	  }
	sprintf(filename,"pzc_pf%d.png",i+1);
	save_png(filename,pic3,NULL);
	}

	strncpy(filename,"flags.png",64);
	save_png(filename,pic,NULL);
	destroy_bitmap(pic);
	destroy_bitmap(pic1);
	destroy_bitmap(pic2);
	destroy_bitmap(pic3);
	destroy_bitmap(pic4);

	sprintf(MapStatusTxt,"PzC flags files saved.\nPick an Operation.");
	main_dlg[dmMapStatusIdx].flags |= D_DIRTY;

	return D_O_K;
}

int save_pzc_tiles(){
	char filename[64];
	int i,c,x,y;
	int columns,rows;
    BITMAP *pic, *pic1;
    int tdx,tdy;

    if (zoom==0){
		tdx = 128;
		tdy = 112;
    }else{
    	tdx = TILE_FULL_WIDTH;
    	tdy = TILE_HEIGHT;
    }

	sprintf(MapStatusTxt,"PzC tiles PNG saving...\nPlease wait.");
	d_mapstatus_proc(MSG_DRAW, &(main_dlg[dmMapStatusIdx]), 0);

	columns=5;
	rows = total_tiles/columns + (total_tiles%columns!=0?1:0);

	pic = create_bitmap_ex(32,136*columns,136*rows);
	clear_bitmap(pic);

	pic1 = create_bitmap_ex(32,TILE_FULL_WIDTH,TILE_HEIGHT);
	clear_bitmap(pic1);

	for(i=0;i<total_tiles;i++){

	for (y=0; y<TILE_HEIGHT; ++y)
	  for (x=0; x<TILE_FULL_WIDTH; ++x){
		  c= getpixel(til_bmp[i],x,y);

		  if ( c!=fpge_mask_color)
			  c |= 0xFF000000;
		  else
			  c=0;
		  putpixel(pic1,x,y,c);
	  }

	stretch_blit(pic1, pic,
			0, 0, TILE_FULL_WIDTH, TILE_HEIGHT,
			( i%columns )*136 +136/2-tdx/2 , i/columns*136+136/2-tdy/2,
			tdx, tdy);
	}

	strncpy(filename,"LayerBaseDry.png",64);
	save_png(filename,pic,NULL);
	destroy_bitmap(pic);
	destroy_bitmap(pic1);

	sprintf(MapStatusTxt,"PzC tiles files saved.\nPick an Operation.");
	main_dlg[dmMapStatusIdx].flags |= D_DIRTY;

	return D_O_K;
}
