/*
 * move.c
 *
 *  Created on: 07-04-2012
 *      Author: wino
 *
 *  Move mode module.
 */

#include <stdio.h>
#include <stdlib.h>

#include "fpge.h"
#include "maingui.h"
#include "drawmap.h"
#include "tables.h"
#include "move.h"

unsigned char move_points[MOVE_MAP_X][MOVE_MAP_Y];
unsigned char move_directions_RC[MOVE_MAP_X][MOVE_MAP_Y];
unsigned char move_points_transport[MOVE_MAP_X][MOVE_MAP_Y];
unsigned char move_directions_transport_RC[MOVE_MAP_X][MOVE_MAP_Y];
unsigned char move_path[MOVE_MAP_X][MOVE_MAP_Y];
int move_x0;
int move_y0;

//panzer.exe 0xbfb27 len288
/* C:\gry\pg\EXE\PANZER.EXE */
/* Big size for PacGen */
unsigned char PgStaticMoveTable[MOVE_BIN_TABLE_SIZE] =
{
  0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x02, 0x04, 0xfe, 0xfe, 0x02, 0x03, 0x02, 0xfe,
  0xfe, 0xfe, 0x01, 0x01, 0x01, 0x04, 0xff, 0x02, 0xff, 0xff, 0xff, 0xfe, 0xff, 0x02, 0x01, 0x02,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x03, 0x02, 0xfe, 0xfe, 0xfe,
  0x02, 0x04, 0x03, 0xfe, 0xfe, 0xfe, 0x01, 0x01, 0x01, 0x04, 0xff, 0x02, 0xff, 0xff, 0xff, 0xfe,
  0xff, 0x02, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04, 0xfe,
  0xfe, 0xfe, 0xfe, 0xfe, 0x04, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x03, 0x03, 0x03, 0xfe, 0xff, 0x03,
  0xff, 0xff, 0xff, 0xfe, 0xff, 0x03, 0x02, 0x04, 0x03, 0x01, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xfe, 0xfe, 0xfe, 0x02, 0x02,
  0x02, 0x02, 0xfe, 0x01, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe,
  0xfe, 0xfe, 0x01, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x01, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x02, 0x02, 0x03, 0x04, 0x04, 0x03, 0xfe, 0x03, 0x03, 0xfe, 0x03, 0xfe, 0xfe, 0xfe, 0x02, 0x02,
  0x02, 0xfe, 0xff, 0x03, 0xff, 0xff, 0xff, 0xfe, 0xff, 0x02, 0x01, 0x03, 0x02, 0x01, 0x01, 0x01
};

/* Generated by HexEdit */
/* C:\gry\test\pg\EXE\PANZER.EXE */
/* size 144 but we need PacGen 8*12*4 size */
unsigned char PgStaticWeatherTable[WEATHER_BIN_TABLE_SIZE] =
{
  0x05, 0x05, 0x5f, 0x3c, 0x05, 0x05, 0x5f, 0x32, 0x0a, 0x05, 0x23, 0x28, 0x0a, 0x05, 0x00, 0x1e,
  0x0c, 0x05, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14,
  0x0c, 0x05, 0x05, 0x14, 0x0a, 0x05, 0x05, 0x23, 0x08, 0x05, 0x23, 0x32, 0x05, 0x05, 0x4b, 0x3c,
  0x05, 0x05, 0x3c, 0x14, 0x05, 0x05, 0x3c, 0x1e, 0x05, 0x05, 0x0f, 0x32, 0x05, 0x05, 0x05, 0x3c,
  0x0a, 0x05, 0x00, 0x32, 0x0c, 0x03, 0x00, 0x14, 0x0c, 0x03, 0x00, 0x14, 0x0c, 0x03, 0x00, 0x14,
  0x0a, 0x05, 0x00, 0x14, 0x05, 0x05, 0x0a, 0x14, 0x05, 0x05, 0x19, 0x14, 0x05, 0x0e, 0x64, 0x4b,
  0x05, 0x05, 0x64, 0x3c, 0x03, 0x06, 0x64, 0x3c, 0x05, 0x05, 0x50, 0x32, 0x05, 0x05, 0x3c, 0x28,
  0x0a, 0x05, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14,
  0x0a, 0x05, 0x00, 0x14, 0x05, 0x05, 0x50, 0x28, 0x05, 0x05, 0x5f, 0x32, 0x05, 0x05, 0x64, 0x3c
};


void move_path_init(){
	memset(move_path,MOVE_NO_PATH,sizeof(move_path));

}
void move_init(){
	move_path_init();
	memset(move_points,MOVE_NOT_CHECKED,sizeof(move_points));
	memset(move_directions_RC,0,sizeof(move_directions_RC));

	memset(move_points_transport,MOVE_NOT_CHECKED,sizeof(move_points_transport));
	memset(move_directions_transport_RC,0,sizeof(move_directions_transport_RC));
}

int get_unit_side(int uid){
	return 0+(all_units[uid].uflag==allied_core || all_units[uid].uflag==allied_aux);
}

int edit_mode_trigger() {

	if (tile_mode == 1) {
		tile_cleanup();
		//restore selected since tile_cleanup removes selected
		main_dlg[dmTileBtnIdx].flags |= D_SELECTED;

		edit_op = move_mode;
	} else {
		if (edit_op != move_mode) {
			edit_op = move_mode;
		} else {
			edit_op = edit_none;
		}
	}
	draw_map(map_bmp, map_x0, map_y0, tiles_high, tiles_wide);

	return 0;
}

int terrain_move_cost(int from_x, int from_y, int to_x, int to_y, int move_type, int direction, int unit_side){
	int multiplyer=ROW_PG_TERRAIN_MOV_TYPES*3;

	//if (pacgen_mode){
	//	multiplyer=ROW_PACGEN_TERRAIN_MOV_TYPES*3;
	//}

	//road OR bridge unit
	if ((map[from_x][from_y].rc & dir_bit_mask_RC[direction]) ||
			(map[to_x][to_y].guidx!=0 &&
			 get_unit_side(map[to_x][to_y].guidx) == unit_side &&
			(  equip_flags[all_units[map[to_x][to_y].guidx].unum]&EQUIPMENT_CAN_BRIDGE_RIVERS)  ) )

		//road move is 0
		return PgStaticMoveTable[0 + showWeather + multiplyer*move_type ];

	if (map_terrain_type_to_movement_terrain[map[to_x][to_y].utr]<MOVEMENT_TYPE_UNKNOWN){
		return PgStaticMoveTable[map_terrain_type_to_movement_terrain[map[to_x][to_y].utr]*3 + showWeather + multiplyer*move_type ];
	}else{
		return MOVEMENT_NOT_POSSIBLE; //move not possible = escrapment
	}
}

int compute_costs(unsigned char move_array[][MOVE_MAP_Y],unsigned char move_dir[][MOVE_MAP_Y], int x,int y,int move_type, int max_move_point, int unit_side){
	int i,xx0,yy0, tcost, changes=0;

	if (move_array[x][y]==0 ) return 0; //no movement points, do not continue

	for(i=0;i<6;i++){
		xx0=x + dx_tab_N_CW[i];
		yy0=y + dy_tab_N_CW[i][x % 2];
		if (xx0 >= 0 && xx0 <= mapx && yy0 >= 0 && yy0 <= mapy){
			tcost = terrain_move_cost(x, y, xx0, yy0, move_type, i, unit_side);
			//if (xx0==10 && yy0==26)  { print_dec(tcost); print_dec(x); print_dec(y); }
			if (move_array[xx0][yy0] == MOVE_NOT_CHECKED) {
				if ((int) move_array[x][y] - tcost >= 0 && tcost < MOVEMENT_ALL && move_array[x][y]!=MOVE_NOT_CHECKED) {
					move_array[xx0][yy0] = move_array[x][y] - tcost;
					move_dir[xx0][yy0] = dir_bit_mask_RC[(i+3)%6];
					changes++;
				}
				if (tcost == MOVEMENT_ALL && move_array[x][y] == max_move_point ) {
					move_array[xx0][yy0] = 0;
					move_dir[xx0][yy0] = dir_bit_mask_RC[(i+3)%6];
					changes++;
				}
			}else{
				//check if better
				if ((int) move_array[x][y] - tcost >= 0 &&
						tcost < MOVEMENT_ALL &&
						move_array[x][y]!=MOVE_NOT_CHECKED &&
						move_array[xx0][yy0] < move_array[x][y] - tcost) {
					move_array[xx0][yy0] = move_array[x][y] - tcost;
					move_dir[xx0][yy0] = dir_bit_mask_RC[(i+3)%6];
					changes++;
				}
			}
		}
	}
	return changes;
}

void compute_move_hexes(unsigned char move_array[][MOVE_MAP_Y],unsigned char move_dir[][MOVE_MAP_Y], int x0, int y0,int move_type,int move_point,int uside){

	move_array[x0][y0]=move_point;
	compute_costs(move_array,move_dir,x0,y0,move_type,move_point,uside);

	int r,i,j,xx0,yy0,l=0, changes=1;

	while(changes){
		changes=0;
		for (r = 1; r <= move_point; r++) {
			for (i = 0; i <= r; i++)
				for (j = -r + i / 2; j <= r - (i + 1) / 2; j++) {
					xx0 = x0 + i;
					yy0 = y0 + j + x0 % 2 * (x0 + i + 1) % 2;
					if (xx0 >= 0 && xx0 <= mapx && yy0 >= 0 && yy0 <= mapy && (j== -r + i / 2 || j== r - (i + 1) / 2 || i== r) ) {
						changes+=compute_costs(move_array,move_dir,xx0,yy0,move_type,move_point,uside);
						//move_points[xx0][yy0]=r;
					}
					xx0 = x0 - i;
					yy0 = y0 + j + x0 % 2 * (x0 + i + 1) % 2;
					if (xx0 >= 0 && xx0 <= mapx && yy0 >= 0 && yy0 <= mapy && (j== -r + i / 2 || j== r - (i + 1) / 2 || i== r) ) {
						changes+=compute_costs(move_array,move_dir,xx0,yy0,move_type,move_point,uside);
						//move_points[xx0][yy0]=r;
					}
					l++;
				}
		}
	}
}

int compute_prefix(int from_x, int from_y, int to_x, int to_y){
	int r = abs(from_x-to_x)-abs(from_y-to_y+from_x%2)*2 +
			(abs(from_x-to_x)==abs(from_y-to_y)*2 && to_y>from_y)*((from_x+1)%2)+
			(abs(from_x-to_x)-2==abs(from_y-to_y)*2 && to_y<=from_y)*((from_x)%2)
			;
	//if (r==0 && (from_x+to_x+1)%2 ) r=1;
	return r>0;
}//+(from_x+to_x)%2
//>(abs(from_y-to_y))*2
//10*abs(from_x-to_x)+(abs(from_y-to_y))
void draw_prefix_for_movements(int x, int y, int r){
	int i,j;
	int x0,y0;

	 move_init();

	if (r<1) return;
	for (i=0;i<=r;i++)
		for (j=-r+i/2;j<=r-(i+1)/2;j++){
			x0=x+i;
			y0=y+j+x%2*(x+i+1)%2;
			move_points[x0][y0]=compute_prefix(x,y,x0,y0);
			x0=x-i;
			y0=y+j+x%2*(x+i+1)%2;
			move_points[x0][y0]=compute_prefix(x,y,x0,y0);
		}
}

int compute_path(int from_x,int from_y,int to_x,int to_y){
	int x,y,i,iter=10;
	int best_v, best_x, best_y, best_i;

	int prefix = compute_prefix( to_x, to_y,from_x, from_y);
	//if (from_x%2) prefix = !prefix;

	x=from_x;
	y=from_y;
	prefix= (x+to_x)%2;
	//print_dec(prefix);
	move_path_init();

	while ( !(x==to_x && y==to_y) && iter>0){
		int set=0;
		for(i=0;i<6;i++){
			int xx=x + dx_tab_N_CW[i];
			int yy=y + dy_tab_N_CW[i][x % 2];
			if (xx<0 || xx>= mapx || yy<0 || yy>= mapy) continue;
			if (!set){
				if (move_points[xx][yy]!=MOVE_NOT_CHECKED){
					best_v=move_points[xx][yy];
					best_x=xx;
					best_y=yy;
					best_i=i;
					set=1;
				}
			}else{
				if (move_points[xx][yy]!=MOVE_NOT_CHECKED  && move_points[xx][yy]>=best_v ){
					if (move_points[xx][yy]>best_v){
						best_v=move_points[xx][yy];
						best_x=xx;
						best_y=yy;
						best_i=i;
					}else{
						if (!prefix && abs(xx-to_x)<abs(best_x-to_x)){
							best_x=xx;
							best_y=yy;
							best_i=i;
						}
						if (prefix && abs(yy-to_y)<abs(best_y-to_y)){
							best_x=xx;
							best_y=yy;
							best_i=i;
						}

					}
				}
			}
		}
		move_path[x][y]=best_i;
		x=best_x;
		y=best_y;
		prefix= (x+to_x)%2;
		iter--;
		//print_dec(x);
		//print_dec(y);
	}


	return 0;
}

int move_click(){
	//map coordinates are in map_mouse_x, map_mouse_y
	int x0 = map_mouse_x;
	int y0 = map_mouse_y;

	//check if there is a unit
	if (map[x0][y0].guidx>=0){//ground unit only
		//print_str("Move click.");
		int uid = map[x0][y0].guidx;
		int uside = get_unit_side(uid);

		move_init();

		//get move points
		int move_point = equip[all_units[uid].unum][MOV];
		int move_type = equip[all_units[uid].unum][MOV_TYPE];
		//print_dec(all_units[uid].unum);
		//print_dec(move_point);

		compute_move_hexes(move_points,move_directions_RC, x0,  y0, move_type, move_point, uside);

		if (all_units[uid].orgtnum!=0){
			//print_dec(all_units[uid].orgtnum);
			//mark also organic transport range
			int move_point = equip[all_units[uid].orgtnum][MOV];
			int move_type = equip[all_units[uid].orgtnum][MOV_TYPE];
			//print_dec(move_point);
			compute_move_hexes(move_points_transport,move_directions_transport_RC, x0,  y0, move_type, move_point, uside);
		}
		move_x0=x0;
		move_y0=y0;

		//print_dec(move_point);
		draw_map(map_bmp, map_x0, map_y0, tiles_high, tiles_wide);
		main_dlg[dmMapBmpIdx].flags |= D_DIRTY;
	}else{
		if (move_points[x0][y0]< MOVE_NOT_CHECKED ){
			//compute path
			compute_path(x0,y0,move_x0,move_y0);
			draw_map(map_bmp, map_x0, map_y0, tiles_high, tiles_wide);
			main_dlg[dmMapBmpIdx].flags |= D_DIRTY;
		}else{
			draw_prefix_for_movements(x0,y0,8);
			draw_map(map_bmp, map_x0, map_y0, tiles_high, tiles_wide);
			main_dlg[dmMapBmpIdx].flags |= D_DIRTY;
		}
	}

	return 0;
}
