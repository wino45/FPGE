/*
 * move.c
 *
 *  Created on: 07-04-2012
 *      Author: wino
 *
 *  Move mode module.
 */

#include <stdio.h>

#include "fpge.h"
#include "maingui.h"
#include "drawmap.h"
#include "tables.h"
#include "move.h"

unsigned char move_points[MOVE_MAP_X][MOVE_MAP_Y];
unsigned char move_directions[MOVE_MAP_X][MOVE_MAP_Y];
unsigned char move_points_t[MOVE_MAP_X][MOVE_MAP_Y];
unsigned char move_directions_t[MOVE_MAP_X][MOVE_MAP_Y];

//panzer.exe 0xbfb27 len288
/* C:\gry\pg\EXE\PANZER.EXE */
unsigned char PgStaticMoveTable[PGF_MOVE_BIN_TABLE_SIZE] =
{
  0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x02, 0x04, 0xfe, 0xfe, 0x02, 0x03, 0x02, 0xfe,
  0xfe, 0xfe, 0x01, 0x01, 0x01, 0x04, 0xff, 0x02, 0xff, 0xff, 0xff, 0xfe, 0xff, 0x02, 0x01, 0x02,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x03, 0x02, 0xfe, 0xfe, 0xfe,
  0x02, 0x04, 0x03, 0xfe, 0xfe, 0xfe, 0x01, 0x01, 0x01, 0x04, 0xff, 0x02, 0xff, 0xff, 0xff, 0xfe,
  0xff, 0x02, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04, 0xfe,
  0xfe, 0xfe, 0xfe, 0xfe, 0x04, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x03, 0x03, 0x03, 0xfe, 0xff, 0x03,
  0xff, 0xff, 0xff, 0xfe, 0xff, 0x03, 0x02, 0x04, 0x03, 0x01, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xfe, 0xfe, 0xfe, 0x02, 0x02,
  0x02, 0x02, 0xfe, 0x01, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe,
  0xfe, 0xfe, 0x01, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x01, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x02, 0x02, 0x03, 0x04, 0x04, 0x03, 0xfe, 0x03, 0x03, 0xfe, 0x03, 0xfe, 0xfe, 0xfe, 0x02, 0x02,
  0x02, 0xfe, 0xff, 0x03, 0xff, 0xff, 0xff, 0xfe, 0xff, 0x02, 0x01, 0x03, 0x02, 0x01, 0x01, 0x01
};

/* Generated by HexEdit */
/* C:\gry\test\pg\EXE\PANZER.EXE */
unsigned char PgStaticWeatherTable[PG_WEATHER_BIN_TABLE_SIZE] =
{
  0x05, 0x05, 0x5f, 0x3c, 0x05, 0x05, 0x5f, 0x32, 0x0a, 0x05, 0x23, 0x28, 0x0a, 0x05, 0x00, 0x1e,
  0x0c, 0x05, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14,
  0x0c, 0x05, 0x05, 0x14, 0x0a, 0x05, 0x05, 0x23, 0x08, 0x05, 0x23, 0x32, 0x05, 0x05, 0x4b, 0x3c,
  0x05, 0x05, 0x3c, 0x14, 0x05, 0x05, 0x3c, 0x1e, 0x05, 0x05, 0x0f, 0x32, 0x05, 0x05, 0x05, 0x3c,
  0x0a, 0x05, 0x00, 0x32, 0x0c, 0x03, 0x00, 0x14, 0x0c, 0x03, 0x00, 0x14, 0x0c, 0x03, 0x00, 0x14,
  0x0a, 0x05, 0x00, 0x14, 0x05, 0x05, 0x0a, 0x14, 0x05, 0x05, 0x19, 0x14, 0x05, 0x0e, 0x64, 0x4b,
  0x05, 0x05, 0x64, 0x3c, 0x03, 0x06, 0x64, 0x3c, 0x05, 0x05, 0x50, 0x32, 0x05, 0x05, 0x3c, 0x28,
  0x0a, 0x05, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14, 0x0c, 0x04, 0x00, 0x14,
  0x0a, 0x05, 0x00, 0x14, 0x05, 0x05, 0x50, 0x28, 0x05, 0x05, 0x5f, 0x32, 0x05, 0x05, 0x64, 0x3c
};



void move_init(){
	memset(move_points,MOVE_NOT_CHECKED,sizeof(move_points));
	memset(move_directions,0,sizeof(move_directions));

	memset(move_points_t,MOVE_NOT_CHECKED,sizeof(move_points_t));
	memset(move_directions_t,0,sizeof(move_directions_t));
}

int get_unit_side(int uid){
	return 0+(all_units[uid].uflag==allied_core || all_units[uid].uflag==allied_aux);
}

int edit_mode_trigger() {

	if (tile_mode == 1) {
		tile_cleanup();
		//restore selected since tile_cleanup removes selected
		main_dlg[dmTileBtnIdx].flags |= D_SELECTED;

		edit_op = move_mode;
	} else {
		if (edit_op != move_mode) {
			edit_op = move_mode;
		} else {
			edit_op = edit_none;
		}
	}
	draw_map(map_bmp, map_x0, map_y0, tiles_high, tiles_wide);

	return 0;
}

int terrain_move_cost(int from_x, int from_y, int to_x, int to_y, int move_type, int direction, int unit_side){

	//road OR bridge unit
	if ((map[from_x][from_y].rc & dir_bit_mask[direction]) ||
			(map[to_x][to_y].guidx!=0 &&
			 get_unit_side(map[to_x][to_y].guidx) == unit_side &&
			(  equip_flags[all_units[map[to_x][to_y].guidx].unum]&EQUIPMENT_CAN_BRIDGE_RIVERS)  ) )

		//road move is 0
		return PgStaticMoveTable[0 + showWeather + 12*3*move_type ];

	if (map_terrain_type_to_movement_terrain[map[to_x][to_y].utr]<MOVEMENT_TYPE_UNKNOWN){
		return PgStaticMoveTable[map_terrain_type_to_movement_terrain[map[to_x][to_y].utr]*3 + showWeather + 12*3*move_type ];
	}else{
		return MOVEMENT_NOT_POSSIBLE; //move not possible = escrapment
	}
}

int compute_costs(unsigned char move_array[][MOVE_MAP_Y],unsigned char move_dir[][MOVE_MAP_Y], int x,int y,int move_type, int max_move_point, int unit_side){
	int i,xx0,yy0, tcost, changes=0;

	if (move_array[x][y]==0 ) return 0; //no movement points, do not continue

	for(i=0;i<6;i++){
		xx0=x + dx_tab[i];
		yy0=y + dy_tab[i][x % 2];
		if (xx0 >= 0 && xx0 <= mapx && yy0 >= 0 && yy0 <= mapy){
			tcost = terrain_move_cost(x, y, xx0, yy0, move_type, i, unit_side);
			//if (xx0==10 && yy0==26)  { print_dec(tcost); print_dec(x); print_dec(y); }
			if (move_array[xx0][yy0] == MOVE_NOT_CHECKED) {
				if ((int) move_array[x][y] - tcost >= 0 && tcost < MOVEMENT_ALL && move_array[x][y]!=MOVE_NOT_CHECKED) {
					move_array[xx0][yy0] = move_array[x][y] - tcost;
					move_dir[xx0][yy0] = dir_bit_mask[(i+3)%6];
					changes++;
				}
				if (tcost == MOVEMENT_ALL && move_array[x][y] == max_move_point ) {
					move_array[xx0][yy0] = 0;
					move_dir[xx0][yy0] = dir_bit_mask[(i+3)%6];
					changes++;
				}
			}else{
				//check if better
				if ((int) move_array[x][y] - tcost >= 0 &&
						tcost < MOVEMENT_ALL &&
						move_array[x][y]!=MOVE_NOT_CHECKED &&
						move_array[xx0][yy0] < move_array[x][y] - tcost) {
					move_array[xx0][yy0] = move_array[x][y] - tcost;
					move_dir[xx0][yy0] = dir_bit_mask[(i+3)%6];
					changes++;
				}
			}
		}
	}
	return changes;
}


void compute_move_hexes(unsigned char move_array[][MOVE_MAP_Y],unsigned char move_dir[][MOVE_MAP_Y], int x0, int y0,int move_type,int move_point,int uside){

	move_array[x0][y0]=move_point;
	compute_costs(move_array,move_dir,x0,y0,move_type,move_point,uside);

	int r,i,j,xx0,yy0,l=0, changes=1;

	while(changes){
		changes=0;
		for (r = 1; r <= move_point; r++) {
			for (i = 0; i <= r; i++)
				for (j = -r + i / 2; j <= r - (i + 1) / 2; j++) {
					xx0 = x0 + i;
					yy0 = y0 + j + x0 % 2 * (x0 + i + 1) % 2;
					if (xx0 >= 0 && xx0 <= mapx && yy0 >= 0 && yy0 <= mapy && (j== -r + i / 2 || j== r - (i + 1) / 2 || i== r) ) {
						changes+=compute_costs(move_array,move_dir,xx0,yy0,move_type,move_point,uside);
						//move_points[xx0][yy0]=r;
					}
					xx0 = x0 - i;
					yy0 = y0 + j + x0 % 2 * (x0 + i + 1) % 2;
					if (xx0 >= 0 && xx0 <= mapx && yy0 >= 0 && yy0 <= mapy && (j== -r + i / 2 || j== r - (i + 1) / 2 || i== r) ) {
						changes+=compute_costs(move_array,move_dir,xx0,yy0,move_type,move_point,uside);
						//move_points[xx0][yy0]=r;
					}
					l++;
				}
		}
	}
}


int move_click(){
	//map coordinates are in map_mouse_x, map_mouse_y
	int x0 = map_mouse_x;
	int y0 = map_mouse_y;

	//check if there is a unit
	if (map[x0][y0].guidx>=0){//ground unit
		//print_str("Move click.");
		int uid = map[x0][y0].guidx;
		int uside = get_unit_side(uid);

		move_init();

		//get move points
		int move_point = equip[all_units[uid].unum][MOV];
		int move_type = equip[all_units[uid].unum][MOV_TYPE];
		//print_dec(all_units[uid].unum);
		//print_dec(move_point);

		compute_move_hexes(move_points,move_directions, x0,  y0, move_type, move_point, uside);

		if (all_units[uid].orgtnum!=0){
			//print_dec(all_units[uid].orgtnum);
			//mark also organic transport range
			int move_point = equip[all_units[uid].orgtnum][MOV];
			int move_type = equip[all_units[uid].orgtnum][MOV_TYPE];
			//print_dec(move_point);
			compute_move_hexes(move_points_t,move_directions_t, x0,  y0, move_type, move_point, uside);
		}

		//print_dec(move_point);
		draw_map(map_bmp, map_x0, map_y0, tiles_high, tiles_wide);
		main_dlg[dmMapBmpIdx].flags |= D_DIRTY;
	}

	return 0;
}
